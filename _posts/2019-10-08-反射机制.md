---
layout:     post
title:      反射机制
subtitle: 
date:       2019-10-08
author:     nine-free
header-img: img/post-bg-cook.jpg
catalog: true
tags:
    - 反射机制
---

## 什么是反射机制
```aidl
Java反射机制是在运行状态中，对于任意一个类，都能知道这个类的所有的属性和方法；对于任何一个对象，
都能够调用它的任何一个方法和属性；这样动态获取信息以及动态调用对象方法的功能就叫做反射。
简单来说反射就是在运行状态解剖一个未知的.class文件，然后获取这个类中的属性和方法，前提是要获取这个类的Class对象
```
## 反射机制相关类

|类名|说明|
|---|---|
|Class|代表类的实体，在运行的Java应用程序中表示类和接口|
|Field|代表类的成员变量（成员变量也称为类的属性）|
| Method | 方法|
| Constructor | 构造方法|

## 使用反射获取类信息
先写两个类备用SupperClass父类 子类SubClass

```aidl
package top.soft1010.java.knowledge.point.reflect;

/**
 * Created by zhangjifu on 19/10/8.
 */
public class SupperClass extends Object {


    private Integer id;
    private String name;
    public static final String super_default_value = "123456";

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    //public 内部类
    public class InnerSuperClass {

    }

    //protected 内部类
    protected class InnerSuperClass2 {

    }

    //private 内部类
    private class InnerSuperClass3 {

    }
}
```

```
package top.soft1010.java.knowledge.point.reflect;

/**
 * Created by zhangjifu on 19/10/8.
 */
public class SubClass extends SupperClass {

    public static final String sub_default_value = "123456";
    private final String finalString = "final String";
    private final int finalInt = 1;
    private final Integer finalInteger = 1;

    private Integer id;
    private String subName;

    public void publicMethod(String name, Integer id) throws NullPointerException, ClassCastException {
        System.out.println("===name:" + name + "  id:" + id + "===");
    }
    private void privateMethod(String name, Integer id) throws NullPointerException, ClassCastException {
        System.out.println("===name:" + name + "  id:" + id + "===");
    }

    public String getFinalString() {
        return finalString;
    }

    public int getFinalInt() {
        return finalInt;
    }

    public Integer getFinalInteger() {
        return finalInteger;
    }

    @Override
    public Integer getId() {
        return id;
    }

    @Override
    public void setId(Integer id) {
        this.id = id;
    }

    public String getSubName() {
        return subName;
    }

    public void setSubName(String subName) {
        this.subName = subName;
    }

    //内部类
    public class InnerSubClass {

    }
}
```
#### 获取变量信息 getFields&getDeclaredFields
getFields获取所有public的成员变量 包含本类和从子类继承来的
getDeclaredFields获取本类所有变量，所有权限
```aidl
package top.soft1010.java.knowledge.point.reflect;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;

/**
 * Created by zhangjifu on 19/10/8.
 */
public class ReflectFieldTest {

    public static void main(String[] args) {
        Class subClassClass = SubClass.class;

        //获取所有public的成员变量 包含本类和从子类继承来的
        Field[] fields1 = subClassClass.getFields();
        for (Field field : fields1) {
            System.out.print(Modifier.toString(field.getModifiers()) + " "
                    + field.getType().getName() + field.getName());
            System.out.println("");
        }
        System.out.println("====");
        //获取本类所有变量，所有权限
        Field[] fields2 = subClassClass.getDeclaredFields();

        for (Field field : fields2) {
            System.out.print(Modifier.toString(field.getModifiers()) + " "
                    + field.getType().getName() + field.getName());
            System.out.println("");
        }
    }
}
```
输出结果:
![image](http://soft1010.top/img/reflect-1.jpg)

#### 获取类的方法信息
getMethods获取自己及父类public的方法
getDeclaredMethods获取本类所有权限的方法
method.getReturnType()获取方法的返回值信息
method.getParameters()获取方法的入参信息
method.getExceptionTypes()获取方法抛出的异常信息
```aidl

package top.soft1010.java.knowledge.point.reflect;

import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Parameter;

/**
 * Created by zhangjifu on 19/10/8.
 */
public class ReflectMethodTest {

    public static void main(String[] args) {

        Class subCls = SubClass.class;
        System.out.println("类名：" + subCls.getName());
        //获取自己及父类public的方法
//        Method[] methods = subCls.getMethods();
        //获取本类所有权限的方法
        Method[] methods = subCls.getDeclaredMethods();
        for (Method method : methods) {
            //获取方法的入参信息
            Parameter[] parameters = method.getParameters();
            System.out.print(Modifier.toString(method.getModifiers()) + " " +
                    method.getReturnType().getName() + " " + method.getName());
            System.out.print("(");
            //入参
            if (parameters != null && parameters.length > 0) {
                StringBuffer argsStr = new StringBuffer();
                for (Parameter parameter : parameters) {
                    argsStr.append(parameter.getType().getName()).append(" ").append(parameter.getName()).append(",");
                }
                System.out.print(argsStr.substring(0, argsStr.length() - 1));
            }
            System.out.print(")");
            //异常信息
            Class[] exceptionClss = method.getExceptionTypes();
            if (exceptionClss != null && exceptionClss.length > 0) {
                System.out.print("throws ");
                StringBuffer exceptionSb = new StringBuffer();
                for (Class exceptionCls : exceptionClss) {
                    exceptionSb.append(exceptionCls.getName()).append(",");
                }
                System.out.print(exceptionSb.substring(0, exceptionSb.length() - 1));
            }
            System.out.println();
        }

    }
}
```
输出结果：
![image](http://soft1010.top/img/reflect-2.jpg)

#### 获取类的内部类信息
getDeclaredClasses 得到该类所有的内部类，除去父类的
getClasses 得到该类及其父类所有的public的内部类
```aidl

package top.soft1010.java.knowledge.point.reflect;

/**
 * Created by zhangjifu on 19/10/8.
 */
public class ReflectClassTest {

    public static void main(String[] args) {
        Class subClass = SubClass.class;

        //getDeclaredClasses 得到该类所有的内部类，除去父类的
        Class[] classes = subClass.getDeclaredClasses();
        for (Class cls : classes) {
            System.out.println(cls.getName());
        }
        System.out.println("========");

        //getClasses得到该类及其父类所有的public的内部类。
        Class[] classes1 = subClass.getClasses();
        for (Class cls : classes1) {
            System.out.println(cls.getName());
        }
    }
}
```
输出结果：
![image](http://soft1010.top/img/reflect-3.jpg)


## 访问或者操作类的变量和方法
上面反映的是动态获取信息，下面动态调用方法
#### 调用方法
私有方法调用需要设置访问权限
privateMethod.setAccessible(true);
```aidl
package top.soft1010.java.knowledge.point.reflect;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

/**
 * Created by zhangjifu on 19/10/9.
 */
public class MethodTest {

    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        SubClass subClass = new SubClass();

        Class cls = subClass.getClass();
        System.out.println("调用私有方法");
        //获取指定方法
        Method privateMethod = cls.getDeclaredMethod("privateMethod", String.class, Integer.class);
        //对于private方法，需要设置访问权限
        privateMethod.setAccessible(true);

        privateMethod.invoke(subClass, "zhang", 321);
        System.out.println("调用公有方法");
        //获取指定方法
        Method publicMethod = cls.getDeclaredMethod("publicMethod", String.class, Integer.class);
        //对于public方法，不需要设置访问权限
//        publicMethod.setAccessible(true);

        publicMethod.invoke(subClass, "zhang", 123456);
    }
}
```
![image](http://soft1010.top/img/reflect-4.jpg)

#### 修改变量
直接上代码 注意私有变量修改值也需要先field.setAccessible(true);
```aidl
 private static void modifyFiled() throws NoSuchFieldException, IllegalAccessException {
        SubClass subClass = new SubClass();
        subClass.setSubName("subname");
        Class cls = subClass.getClass();

        Field field = cls.getDeclaredField("subName");
        System.out.println();
        //设置访问权限
        field.setAccessible(true);
        System.out.println("old subname:" + subClass.getSubName());
        //field是私有变量 subClass是要修改的对象 subNameNew是修改成的目标值
        field.set(subClass, "subNameNew");
        System.out.println("new subname:" + subClass.getSubName());

    }
```
输出结果：
```aidl
old subname:subname
new subname:subNameNew
```
#### 修改私有常量
还是先上一段代码
```aidl
private static void modifyFinalFiled() throws NoSuchFieldException, IllegalAccessException {
        SubClass subClass = new SubClass();
        Class cls = subClass.getClass();

        Field field = cls.getDeclaredField("finalInt");
        System.out.println("私有变量finalInt 通过反射修改 值 1--> 2");
        //设置访问权限
        field.setAccessible(true);
        //直接获取对象指定私有常量的值
        System.out.println("反射前 finalInt:" + field.get(subClass));
        //通过get方法获取私有常量的值
        System.out.println("反射前 getfinalInt():" + subClass.getFinalInt());
        //field是私有变量 subClass是要修改的对象 subNameNew是修改成的目标值
        field.set(subClass, 2);
        //直接获取修改后对象指定私有常量的值
        System.out.println("反射后 finalInt:" + field.get(subClass));
        //通过get方法获取修改后私有常量的值
        System.out.println("反射后 getfinalInt():" + subClass.getFinalInt());

        System.out.println("===华丽的分割线===");
        System.out.println("私有变量finalInteger 通过反射修改 11-->12");
        Field field1 = cls.getDeclaredField("finalInteger");
        //设置访问权限
        field1.setAccessible(true);
        //直接获取对象指定私有常量的值
        System.out.println("反射前 finalInteger:" + field1.get(subClass));
        //通过get方法获取私有常量的值
        System.out.println("反射前 getfinalInteger():" + subClass.getFinalInteger());
        //field是私有变量 subClass是要修改的对象 subNameNew是修改成的目标值
        field1.set(subClass, 12);
        //直接获取修改后对象指定私有常量的值
        System.out.println("反射后 finalInteger:" + field1.get(subClass));
        //通过get方法获取修改后私有常量的值
        System.out.println("反射后 getfinalInteger():" + subClass.getFinalInteger());

    }
```
输出结果:
```
私有变量finalInt 通过反射修改 值 1--> 2
反射前 finalInt:1
反射前 getfinalInt():1
反射后 finalInt:2
反射后 getfinalInt():1
===华丽的分割线===
私有变量finalInteger 通过反射修改 11-->12
反射前 finalInteger:11
反射前 getfinalInteger():11
反射后 finalInteger:12
反射后 getfinalInteger():12
```
- 1、通过反射修改私有常量值肯定是可行的。
  field.get(subClass)这个方法得到修改后的值，无论是基本类型int还是包装类型Integer都是可以的

- 2、为什么常量类型分别为int和Integer的值，通过get方法得到的结果不一致呢？
  下面我们看看编制之后的字节码文件反编译出来的java类
```
package top.soft1010.java.knowledge.point.reflect;

import top.soft1010.java.knowledge.point.reflect.SupperClass;

public class SubClass extends SupperClass {
    public static final String sub_default_value = "123456";
    private final String finalString = "final String";
    private final int finalInt = 1;
    private final Integer finalInteger = Integer.valueOf(11);
    private Integer id;
    private String subName;

    public SubClass() {
    }

    public void publicMethod(String name, Integer id) throws NullPointerException, ClassCastException {
        System.out.println("===name:" + name + "  id:" + id + "===");
    }

    private void privateMethod(String name, Integer id) throws NullPointerException, ClassCastException {
        System.out.println("===name:" + name + "  id:" + id + "===");
    }
    //1、String类型的常量值，编译之后引用常量的位置直接被常量值替换了
    public String getFinalString() {
        return "final String";
    }
    //2、int基本类型的常量值，编译之后引用常量的位置也直接被产量值替换了
    public int getFinalInt() {
        return 1;
    }
    //3、Integer包装类型的的常量值，还是引用原来的常量，如果常量变化了，
    //这个get方法返回值也会跟着变化
    public Integer getFinalInteger() {
        return this.finalInteger;
    }

    public Integer getId() {
        return this.id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getSubName() {
        return this.subName;
    }

    public void setSubName(String subName) {
        this.subName = subName;
    }

    public class InnerSubClass {
        public InnerSubClass() {
        }
    }
```

我们在程序运行时刻依然可以使用反射修改常量的值，
但是 JVM 在编译阶段得到的 .class 文件已经将常量优化为具体的值，
在运行阶段就直接使用具体的值了，所以即使修改了常量的值也已经毫无意义了
get方法获取到的还是替换之后的具体常量值，但是非基本类型jvm并没有做这个优化操作

[源码在这里](https://github.com/nine-free/java-base)



