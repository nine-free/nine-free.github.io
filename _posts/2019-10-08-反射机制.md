---
layout:     post
title:      反射机制
subtitle: 
date:       2019-10-08
author:     nine-free
header-img: img/post-bg-cook.jpg
catalog: true
tags:
    - 反射机制
---

## 什么是反射机制
```aidl
Java反射机制是在运行状态中，对于任意一个类，都能知道这个类的所有的属性和方法；对于任何一个对象，
都能够调用它的任何一个方法和属性；这样动态获取信息以及动态调用对象方法的功能就叫做反射。
简单来说反射就是在运行状态解剖一个未知的.class文件，然后获取这个类中的属性和方法，前提是要获取这个类的Class对象
```
## 反射机制相关类

|类名|说明|
|---|---|
|Class|代表类的实体，在运行的Java应用程序中表示类和接口|
|Field|代表类的成员变量（成员变量也称为类的属性）|
| Method | 方法|
| Constructor | 构造方法|

## 使用反射获取类信息
先写两个类备用SupperClass父类 子类SubClass

```aidl
package top.soft1010.java.knowledge.point.reflect;

/**
 * Created by zhangjifu on 19/10/8.
 */
public class SupperClass extends Object {


    private Integer id;
    private String name;
    public static final String super_default_value = "123456";

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    //public 内部类
    public class InnerSuperClass {

    }

    //protected 内部类
    protected class InnerSuperClass2 {

    }

    //private 内部类
    private class InnerSuperClass3 {

    }
}
```

```
package top.soft1010.java.knowledge.point.reflect;

/**
 * Created by zhangjifu on 19/10/8.
 */
public class SubClass extends SupperClass {

    public static final String sub_default_value = "123456";
    private final String finalString = "final String";
    private final int finalInt = 1;
    private final Integer finalInteger = 1;

    private Integer id;
    private String subName;

    public void publicMethod(String name, Integer id) throws NullPointerException, ClassCastException {
        System.out.println("===name:" + name + "  id:" + id + "===");
    }
    private void privateMethod(String name, Integer id) throws NullPointerException, ClassCastException {
        System.out.println("===name:" + name + "  id:" + id + "===");
    }

    public String getFinalString() {
        return finalString;
    }

    public int getFinalInt() {
        return finalInt;
    }

    public Integer getFinalInteger() {
        return finalInteger;
    }

    @Override
    public Integer getId() {
        return id;
    }

    @Override
    public void setId(Integer id) {
        this.id = id;
    }

    public String getSubName() {
        return subName;
    }

    public void setSubName(String subName) {
        this.subName = subName;
    }

    //内部类
    public class InnerSubClass {

    }
}
```
#### 获取变量信息 getFields&getDeclaredFields
getFields获取所有public的成员变量 包含本类和从子类继承来的
getDeclaredFields获取本类所有变量，所有权限
```
    /**
     * getFields 获取所有public的成员变量 包含本类和从子类继承来的
     *
     * @param cls
     */
    public static void parseFileds(Class cls) {
        //获取所有public的成员变量 包含本类和从子类继承来的
        Field[] fields1 = cls.getFields();
        for (Field field : fields1) {
            System.out.print(Modifier.toString(field.getModifiers()) + " "
                    + field.getType().getName() + field.getName());
            System.out.println("");
        }
    }

     /**
     * getDeclaredFields 获取本类所有变量，所有权限
     *
     * @param cls
     */
    public static void parseDeclaredFileds(Class cls) {
        //获取本类所有变量，所有权限
        Field[] fields2 = cls.getDeclaredFields();

        for (Field field : fields2) {
            System.out.print(Modifier.toString(field.getModifiers()) + " "
                    + field.getType().getName() + field.getName());
            System.out.println("");
        }
    }
```
输出结果:
```
public static final java.lang.Stringsub_default_value
public static final java.lang.Stringsuper_default_value
===华丽的分割线===
public static final java.lang.Stringsub_default_value
private final java.lang.StringfinalString
private final intfinalInt
private final java.lang.IntegerfinalInteger
private java.lang.Integerid
private java.lang.StringsubName
```
#### 获取类的方法信息
getMethods获取自己及父类public的方法
getDeclaredMethods获取本类所有权限的方法
method.getReturnType()获取方法的返回值信息
method.getParameters()获取方法的入参信息
method.getExceptionTypes()获取方法抛出的异常信息
```
    /**
     * 获取类的方法
     *
     * @param cls
     */
    public static void parseMethods(Class cls) {
        //获取自己及父类public的方法
        //Method[] methods = subCls.getMethods();
        //获取本类所有权限的方法
        Method[] methods = cls.getDeclaredMethods();
        for (Method method : methods) {
            //获取方法的入参信息
            Parameter[] parameters = method.getParameters();
            System.out.print(Modifier.toString(method.getModifiers()) + " " +
                    method.getReturnType().getName() + " " + method.getName());
            System.out.print("(");
            //入参
            if (parameters != null && parameters.length > 0) {
                StringBuffer argsStr = new StringBuffer();
                for (Parameter parameter : parameters) {
                    argsStr.append(parameter.getType().getName()).append(" ").append(parameter.getName()).append(",");
                }
                System.out.print(argsStr.substring(0, argsStr.length() - 1));
            }
            System.out.print(")");
            //异常信息
            Class[] exceptionClss = method.getExceptionTypes();
            if (exceptionClss != null && exceptionClss.length > 0) {
                System.out.print("throws ");
                StringBuffer exceptionSb = new StringBuffer();
                for (Class exceptionCls : exceptionClss) {
                    exceptionSb.append(exceptionCls.getName()).append(",");
                }
                System.out.print(exceptionSb.substring(0, exceptionSb.length() - 1));
            }
            System.out.println();
        }
    }
```
输出结果：
```
public java.lang.Integer getId()
public void setId(java.lang.Integer arg0)
public void publicMethod(java.lang.String arg0,java.lang.Integer arg1)throws java.lang.NullPointerException,java.lang.ClassCastException
private void privateMethod(java.lang.String arg0,java.lang.Integer arg1)throws java.lang.NullPointerException,java.lang.ClassCastException
public java.lang.String getFinalString()
public int getFinalInt()
public java.lang.Integer getFinalInteger()
public java.lang.String getSubName()
public void setSubName(java.lang.String arg0)
```
#### 获取类的内部类信息
getDeclaredClasses 得到该类所有的内部类，除去父类的
getClasses 得到该类及其父类所有的public的内部类
```
    /**
     * getClasses 得到该类及其父类所有的public的内部类
     *
     * @param cls
     */
    public static void parseInnerClass(Class cls) {
        //getClasses 得到该类及其父类所有的public的内部类。
        Class[] classes = cls.getClasses();
        for (Class clz : classes) {
            System.out.println(clz.getName());
        }
    }

    /**
     * getDeclaredClasses 得到该类所有的内部类，除去父类的
     *
     * @param cls
     */
    public static void parseInnerDeclaredClass(Class cls) {
        //getDeclaredClasses 得到该类所有的内部类，除去父类的
        Class[] classes = cls.getDeclaredClasses();
        for (Class clz : classes) {
            System.out.println(clz.getName());
        }
    }
```
输出结果：
```
top.soft1010.java.knowledge.point.reflect.SubClass$InnerSubClass
top.soft1010.java.knowledge.point.reflect.SupperClass$InnerSuperClass
===华丽的分割线===
top.soft1010.java.knowledge.point.reflect.SubClass$InnerSubClass
```

## 访问或者操作类的变量和方法
上面反映的是动态获取信息，下面动态调用方法
#### 调用方法
私有方法调用需要设置访问权限
privateMethod.setAccessible(true);
```
     /**
     * 动态调用类的私有方法
     *
     * @param cls
     * @throws IllegalAccessException
     * @throws InstantiationException
     * @throws NoSuchMethodException
     * @throws InvocationTargetException
     */
    public static void invokePrivateMethod(Class cls) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {
        //获取指定方法
        Method privateMethod = cls.getDeclaredMethod("privateMethod", String.class, Integer.class);
        //对于private方法，需要设置访问权限
        privateMethod.setAccessible(true);

        privateMethod.invoke(cls.newInstance(), "zhang", 321);
        System.out.println("调用公有方法");
        //获取指定方法
        Method publicMethod = cls.getDeclaredMethod("publicMethod", String.class, Integer.class);
        //对于public方法，不需要设置访问权限
        //publicMethod.setAccessible(true);

        publicMethod.invoke(cls.newInstance(), "zhang", 123456);

    }
```
输出结果：
```
===name:zhang  id:123456===
```
#### 修改变量
直接上代码 注意私有变量修改值也需要先field.setAccessible(true);
```
 /**
     * 修改私有变量
     *
     * @throws NoSuchFieldException
     * @throws IllegalAccessException
     */
    public static void modifyFiled() throws NoSuchFieldException, IllegalAccessException {
        SubClass subClass = new SubClass();
        subClass.setSubName("subname");
        Class cls = subClass.getClass();
        Field field = cls.getDeclaredField("subName");
        System.out.println();
        //设置访问权限
        field.setAccessible(true);
        System.out.println("修改前 subname:" + subClass.getSubName());
        //field是私有变量 subClass是要修改的对象 subNameNew是修改成的目标值
        field.set(subClass, "subNameNew");
        System.out.println("修改后 subname:" + subClass.getSubName());
    }
```
输出结果：
```aidl
修改前 subname:subname
修改后 subname:subNameNew
```
#### 修改私有常量
还是先上一段代码
```
 /**
     * 修改私有常量
     *
     * @throws NoSuchFieldException
     * @throws IllegalAccessException
     */
    public static void modifyFinalFiled() throws NoSuchFieldException, IllegalAccessException {
        SubClass subClass = new SubClass();
        Class cls = subClass.getClass();
        Field field = cls.getDeclaredField("finalInt");
        System.out.println("私有变量finalInt 通过反射修改 值 1--> 2");
        //设置访问权限
        field.setAccessible(true);
        //直接获取对象指定私有常量的值
        System.out.println("反射前 finalInt:" + field.get(subClass));
        //通过get方法获取私有常量的值
        System.out.println("反射前 getfinalInt():" + subClass.getFinalInt());
        //field是私有变量 subClass是要修改的对象 subNameNew是修改成的目标值
        field.set(subClass, 2);
        //直接获取修改后对象指定私有常量的值
        System.out.println("反射后 finalInt:" + field.get(subClass));
        //通过get方法获取修改后私有常量的值
        System.out.println("反射后 getfinalInt():" + subClass.getFinalInt());

        System.out.println("===华丽的分割线===");
        System.out.println("私有变量finalInteger 通过反射修改 11-->12");
        Field field1 = cls.getDeclaredField("finalInteger");
        //设置访问权限
        field1.setAccessible(true);
        //直接获取对象指定私有常量的值
        System.out.println("反射前 finalInteger:" + field1.get(subClass));
        //通过get方法获取私有常量的值
        System.out.println("反射前 getfinalInteger():" + subClass.getFinalInteger());
        //field是私有变量 subClass是要修改的对象 subNameNew是修改成的目标值
        field1.set(subClass, 12);
        //直接获取修改后对象指定私有常量的值
        System.out.println("反射后 finalInteger:" + field1.get(subClass));
        //通过get方法获取修改后私有常量的值
        System.out.println("反射后 getfinalInteger():" + subClass.getFinalInteger());
    }
```
输出结果:
```
私有变量finalInt 通过反射修改 值 1--> 2
反射前 finalInt:1
反射前 getfinalInt():1
反射后 finalInt:2
反射后 getfinalInt():1
===华丽的分割线===
私有变量finalInteger 通过反射修改 11-->12
反射前 finalInteger:11
反射前 getfinalInteger():11
反射后 finalInteger:12
反射后 getfinalInteger():12
```
- 1、通过反射修改私有常量值肯定是可行的。
  field.get(subClass)这个方法得到修改后的值，无论是基本类型int还是包装类型Integer都是可以的

- 2、为什么常量类型分别为int和Integer的值，通过get方法得到的结果不一致呢？
  下面我们看看编制之后的字节码文件反编译出来的java类
```
package top.soft1010.java.knowledge.point.reflect;

import top.soft1010.java.knowledge.point.reflect.SupperClass;

public class SubClass extends SupperClass {
    public static final String sub_default_value = "123456";
    private final String finalString = "final String";
    private final int finalInt = 1;
    private final Integer finalInteger = Integer.valueOf(11);
    private Integer id;
    private String subName;

    public SubClass() {
    }

    public void publicMethod(String name, Integer id) throws NullPointerException, ClassCastException {
        System.out.println("===name:" + name + "  id:" + id + "===");
    }

    private void privateMethod(String name, Integer id) throws NullPointerException, ClassCastException {
        System.out.println("===name:" + name + "  id:" + id + "===");
    }
    //1、String类型的常量值，编译之后引用常量的位置直接被常量值替换了
    public String getFinalString() {
        return "final String";
    }
    //2、int基本类型的常量值，编译之后引用常量的位置也直接被产量值替换了
    public int getFinalInt() {
        return 1;
    }
    //3、Integer包装类型的的常量值，还是引用原来的常量，如果常量变化了，
    //这个get方法返回值也会跟着变化
    public Integer getFinalInteger() {
        return this.finalInteger;
    }

    public Integer getId() {
        return this.id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getSubName() {
        return this.subName;
    }

    public void setSubName(String subName) {
        this.subName = subName;
    }

    public class InnerSubClass {
        public InnerSubClass() {
        }
    }
```

我们在程序运行时刻依然可以使用反射修改常量的值，
但是 JVM 在编译阶段得到的 .class 文件已经将常量优化为具体的值，
在运行阶段就直接使用具体的值了，所以即使修改了常量的值也已经毫无意义了
get方法获取到的还是替换之后的具体常量值，但是非基本类型jvm并没有做这个优化操作

## 动态加载字节码文件(.class文件),获取类信息
直接上代码
```aidl
/**
     * 加载指定.class文件
     *
     * @param filePath
     * @return
     * @throws Exception
     */
    public static List<Class> loacExtendClass(String filePath) throws Exception {
        List<Class> classes = new ArrayList<>(16);
        filePath = "/Users/zhangjifu/myproject/java-base/src/main/java/";
        // 设置class文件所在根路径
        // 例如/usr/java/classes下有一个test.App类，则/usr/java/classes即这个类的根路径，而.class文件的实际位置是/usr/java/classes/test/App.class
        File clazzPath = new File(filePath);

        // 记录加载.class文件的数量
        int clazzCount = 0;

        if (clazzPath.exists() && clazzPath.isDirectory()) {
            // 获取路径长度
            int clazzPathLen = clazzPath.getAbsolutePath().length() + 1;

            Stack<File> stack = new Stack<>();
            stack.push(clazzPath);

            // 遍历类路径
            while (stack.isEmpty() == false) {
                File path = stack.pop();
                File[] classFiles = path.listFiles(new FileFilter() {
                    public boolean accept(File pathname) {
                        return pathname.isDirectory() || pathname.getName().endsWith(".class");
                    }
                });
                for (File subFile : classFiles) {
                    if (subFile.isDirectory()) {
                        stack.push(subFile);
                    } else {
                        if (clazzCount++ == 0) {
                            Method method = URLClassLoader.class.getDeclaredMethod("addURL", URL.class);
                            boolean accessible = method.isAccessible();
                            try {
                                if (accessible == false) {
                                    method.setAccessible(true);
                                }
                                // 设置类加载器
                                URLClassLoader classLoader = (URLClassLoader) ClassLoader.getSystemClassLoader();
                                // 将当前类路径加入到类加载器中
                                method.invoke(classLoader, clazzPath.toURI().toURL());
                            } finally {
                                method.setAccessible(accessible);
                            }
                        }
                        // 文件名称
                        String className = subFile.getAbsolutePath();
                        className = className.substring(clazzPathLen, className.length() - 6);
                        className = className.replace(File.separatorChar, '.');
                        // 加载Class类
                        Class cls = Class.forName(className);
                        System.out.println("读取应用程序类文件 " + className);
                        classes.add(cls);
                    }
                }
            }
        }
        return classes;
    }

```


[源码在这里](https://github.com/nine-free/java-base)



